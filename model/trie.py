# coding:utf-8
from collections import defaultdict

class TrieNode:
    """Trie Nodes"""
    def __init__(self):
        self.children = defaultdict(TrieNode)
        self.is_end_of_word = False

class Trie:
    """
    Data Structure of the Trie for Constrained Decoding.
    When generating recommendation results, ensure that the semantic IDs generated by the model exist in the dataset.
    By inserting all valid semantic ID sequences into a Trie, we can efficiently find all possible and valid next tokens at each decoding step based on the already generated prefix.
    """
    def __init__(self, special_tokens=None):
        """
        Initialize an empty Trie.
        
        Args:
            special_tokens (dict, optional): A dictionary of special tokens, e.g., {'EOS': 257}. The EOS token is added to the end of every sequence.
        """
        self.root = TrieNode()
        self.eos_token = special_tokens.get('EOS') if special_tokens else None

    def insert(self, sequence):
        """
        Insert a valid sequence into the Trie.

        Args:
            sequence: A sequence of integers representing a valid semantic ID.
        """
        node = self.root
        for token in sequence:
            node = node.children[token]
        node.is_end_of_word = True
        
        # If an EOS token is provided, add a path to the EOS token at the end of the sequence.
        if self.eos_token is not None:
            node.children[self.eos_token] = TrieNode()

    def get_next_valid_tokens(self, prefix):
        """
        Given a prefix, return all valid next tokens.
        Args:
            prefix (list or tuple of int): The currently generated token sequence.

        Returns:
            set: A set containing all valid next tokens. Returns an empty set if the prefix is invalid or if a terminal node has been reached.
        """
        node = self.root
        for token in prefix:
            if token in node.children:
                node = node.children[token]
            else:
                # If the prefix does not exist in the tree, there are no valid next tokens.
                return set()
        
        # Return the keys of all child nodes of the current node (i.e., the valid next tokens).
        return set(node.children.keys())

def build_trie_from_id_map(item_to_semantic_id, special_tokens):
    """
    Build a Trie tree from the mapping of item IDs to semantic IDs.

    Args:
        item_to_semantic_id (dict): {item_id: (id_part1, id_part2, ...)}
        special_tokens (dict): Special token dictionary.

    Returns:
        Trie: The constructed Trie.
    """
    trie = Trie(special_tokens)
    for semantic_id in item_to_semantic_id.values():
        trie.insert(semantic_id)
    return trie



